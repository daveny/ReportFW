@{
    ViewBag.Title = "Metric Editor";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

@section styles {
    <style>
        :root {
            --card-bg: var(--bs-body-bg, #fff);
        }

        .page {
            display: grid;
            grid-template-rows: auto 1fr;
            gap: 16px;
        }

        .top {
            display: grid;
            grid-template-columns: 440px 1fr;
            gap: 16px;
            align-items: start;
        }

        .bottom {
        }

        .card {
            background: var(--card-bg);
            border: 1px solid rgba(0,0,0,.08);
            border-radius: 12px;
            box-shadow: 0 1px 2px rgba(0,0,0,.04);
        }

            .card h5 {
                margin: 0 0 10px 0;
                font-weight: 600;
            }

            .card .body {
                padding: 14px;
            }

        .row {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .row-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .row-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }

        .btn-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .muted {
            color: #6c757d;
            font-size: .9rem;
        }

        label {
            font-weight: 600;
        }

        input[type="text"], select, textarea {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid rgba(0,0,0,.2);
            border-radius: 8px;
            background: var(--card-bg);
        }

            textarea#generatedCode {
                height: 48vh;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                font-size: 12.8px;
            }

            textarea#rawInput {
                height: 18vh;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                font-size: 12.8px;
            }

            textarea#querySql {
                height: 18vh;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                font-size: 12.8px;
            }

        iframe#previewFrame {
            width: 100%;
            height: 56vh;
            border: 1px solid rgba(0,0,0,.12);
            border-radius: 10px;
            background: #fff;
        }

        .danger {
            color: #b42318;
        }

        /* Razor escape: */
        @@media (max-width: 1200px) {
            .top {
                grid-template-columns: 1fr;
            }

            textarea#generatedCode {
                height: 34vh;
            }

            iframe#previewFrame {
                height: 50vh;
            }
        }
    </style>
}

<!-- Anti-forgery token (cookie + hidden input) -->
<div id="af-token" style="display:none">@Html.AntiForgeryToken()</div>

<div class="page">
    <div class="top">
        <!-- LEFT: inputs -->
        <div class="card">
            <div class="body">
                <h5>Metrika kiválasztás / fájlkezelés</h5>
                <div class="row">
                    <div class="row-3" id="metricPickerRow">
                        <div>
                            <label for="metricSelect">Metrika</label>
                            <select id="metricSelect"><option value="">– betöltés… –</option></select>
                        </div>
                        <div>
                            <label for="metricName">Fájlnév</label>
                            <input id="metricName" type="text" placeholder="pl. metric01.thtml" />
                        </div>
                        <div class="btn-row" style="align-items:end">
                            <button id="btnRefreshList" class="btn btn-outline-secondary" type="button">Lista frissítése</button>
                            <button id="btnLoad" class="btn btn-outline-secondary" type="button">Betöltés</button>
                            <button id="btnSave" class="btn btn-outline-secondary" type="button">Mentés</button>
                            <button id="btnSaveAs" class="btn btn-outline-secondary" type="button">Mentés másként</button>
                        </div>
                    </div>
                    <div class="kv">
                        <label for="rawInput">Eredeti THML (meglévő szerkesztésekor)</label>
                        <textarea id="rawInput" placeholder="Ha itt van tartalom, a generált chart blokk kicseréli a meglévő chart blokkot; a filter blokkok érintetlenek maradnak."></textarea>
                        <div class="muted">Ha üres, csak a chart blokk kerül a kimenetbe.</div>
                    </div>
                </div>
                <hr />
                <h5>Chart blokk beállítások</h5>
                <div class="row">
                    <div class="row-2">
                        <div><label for="series">Series (Y)</label><input id="series" type="text" value="TotalSales"></div>
                        <div><label for="groupby">Group by (X csoport)</label><input id="groupby" type="text" value="CountryRegionCode"></div>
                    </div>
                    <div class="row-2">
                        <div><label for="legends">Legends (X legend)</label><input id="legends" type="text" value="OrderYear"></div>
                        <div><label for="title">Cím</label><input id="title" type="text" value="Revenue by Country and Year"></div>
                    </div>
                    <div>
                        <label for="querySql">SQL (többsoros, nyers – csak a dupla idéző \" lesz escape-elve)</label>
                        <textarea id="querySql"></textarea>
                    </div>
                    <div class="btn-row">
                        <button id="btnBuild" class="btn btn-primary" type="button">Chart blokk generálása</button>
                        <button id="btnGenerateThtml" class="btn btn-outline-primary" type="button">THML összeállítása</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- RIGHT: generated THML code -->
        <div class="card">
            <div class="body">
                <h5>Generált .thtml kód</h5>
                <textarea id="generatedCode" readonly></textarea>
                <div class="muted">Parser hotfix aktív: vesszők és egyes idézők sem vágják el a query-t.</div>
            </div>
        </div>
    </div>

    <!-- BOTTOM: preview -->
    <div class="bottom card">
        <div class="body">
            <h5>Élő előnézet</h5>
            <div class="muted">A THML szerveroldali renderje után az iframe-ben újrainjektáljuk a scripteket, hogy tényleg lefussanak.</div>
            <div style="margin:10px 0;" class="btn-row">
                <button id="btnPreview" class="btn btn-success" type="button">Előnézet frissítése</button>
            </div>
            <iframe id="previewFrame" title="Preview"></iframe>
            <div id="previewErr" class="danger" style="margin-top:8px;"></div>
        </div>
    </div>
</div>

@section scripts {
    <script>
(function(){
    // —— Endpoints ——
    const renderUrl = '@Url.Action("RenderPreview", "Editor")';
    const loadUrl   = '@Url.Action("LoadMetric",    "Editor")';
    const saveUrl   = '@Url.Action("SaveMetric",    "Editor")';
    const listUrl   = '@Url.Action("ListMetrics",   "Editor")'; // -> JSON: ["metric01.thtml", ...]

    // —— Elements ——
    const el = {
        metricSelect: $('#metricSelect')[0], metricName: $('#metricName')[0],
        series: $('#series')[0], legends: $('#legends')[0], groupby: $('#groupby')[0], title: $('#title')[0],
        querySql: $('#querySql')[0], rawInput: $('#rawInput')[0], generated: $('#generatedCode')[0],
        preview: $('#previewFrame')[0], previewErr: $('#previewErr')[0]
    };

    // —— Anti-forgery token ——
    const afTokenEl = document.querySelector('input[name="__RequestVerificationToken"]');
    const afToken = afTokenEl ? afTokenEl.value : null;

    // —— Helper: form POST antiforgery-vel ——
    async function postForm(url, fields){
        const form = new URLSearchParams();
        if (afToken) form.set('__RequestVerificationToken', afToken);
        for (const k in fields) if (Object.prototype.hasOwnProperty.call(fields,k)) form.set(k, fields[k]);
        const resp = await fetch(url, {
            method: 'POST', credentials: 'same-origin',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8' },
            body: form.toString()
        });
        return resp;
    }

    // —— Robust parser / serializer ——
    function getKv(inner, key){
        const re = new RegExp('(?:^|;)\\s*' + key + '\\s*=\\s*"([\\s\\S]*?)"\\s*;', 's');
        const m = inner.match(re); return m ? m[1] : null;
    }
    function setKv(inner, key, value){
        const esc = (s) => String(s ?? '').replaceAll('"', '\\"');
        const line = key + '="' + esc(value) + '";';
        const re = new RegExp('((?:^|;)\\s*)' + key + '\\s*=\\s*"([\\s\\S]*?)"\\s*;', 's');
        if (re.test(inner)) return inner.replace(re, '$1' + line);
        return (inner ? inner.replace(/\s*$/s, function(m){return '\n  ' + line + m;}) : ('  ' + line + '\n'));
    }
    function parseChartBlock(blockText){
        const inner = blockText.trim().replace(/^\{\{/, '').replace(/\}\}\s*$/, '').trim();
        return {
            query: getKv(inner, 'query') ?? '',
            representation: getKv(inner, 'representation') ?? 'barchart',
            series: getKv(inner, 'series') ?? '',
            legends: getKv(inner, 'legends') ?? '',
            groupby: getKv(inner, 'groupby') ?? '',
            formatting: getKv(inner, 'formatting') ?? ''
        };
    }
    function buildChartBlock(state){
        let inner = '';
        inner = setKv(inner, 'query', state.query ?? '');
        inner = setKv(inner, 'representation', state.representation ?? 'barchart');
        inner = setKv(inner, 'series', state.series ?? '');
        inner = setKv(inner, 'legends', state.legends ?? '');
        inner = setKv(inner, 'groupby', state.groupby ?? '');
        if (state.formatting) inner = setKv(inner, 'formatting', state.formatting);
        inner = inner.split('\n').map(function(l){ return l ? '  ' + l : l; }).join('\n');
        return '{{\n' + inner + '\n}}';
    }

    // —— {{ ... }} blokkok keresése ——
    function findBlocks(thml){
        const re = /\{\{[\s\S]*?\}\}/g; const blocks = []; let m;
        while ((m = re.exec(thml))){ blocks.push({ start: m.index, end: re.lastIndex, text: m[0] }); }
        return blocks;
    }
    function isFilterBlock(text){ return /representation\s*=\s*"filter"/i.test(text); }
    function isChartLike(text){ return /query\s*=\s*"/i.test(text) && !isFilterBlock(text); }

    // —— THML összeállítás ——
    function generateThtml(){
        const base = el.rawInput.value || '';
        const chartBlock = buildChartBlock({
            query: el.querySql.value, representation: 'barchart', series: el.series.value,
            legends: el.legends.value, groupby: el.groupby.value,
            formatting: el.title.value ? '{ title: "' + el.title.value.replaceAll('"','\\\"') + '" }' : ''
        });
        if (!base){ el.generated.value = chartBlock; return chartBlock; }
        const blocks = findBlocks(base);
        if (!blocks.length){ el.generated.value = chartBlock; return chartBlock; }
        let replaced = false, out = '', last = 0;
        for (var i=0;i<blocks.length;i++){
            const b = blocks[i];
            if (!replaced && isChartLike(b.text)) { out += base.slice(last, b.start) + chartBlock; last = b.end; replaced = true; }
        }
        if (!replaced) out = base + (base.endsWith('\n') ? '' : '\n') + chartBlock + '\n';
        else out += base.slice(last);
        el.generated.value = out; return out;
    }

    // —— Preview ——
    async function refreshPreview(){
        el.previewErr.textContent = '';
        const thml = el.generated.value || generateThtml();
        const candidates = ['thtmlCode','thml','content'];
        let html = null, lastErr = null;
        for (const key of candidates){
            try {
                const resp = await postForm(renderUrl, { [key]: thml });
                if (resp.ok){ html = await resp.text(); break; }
                lastErr = 'HTTP ' + resp.status;
            } catch (e){ lastErr = e && e.message ? e.message : String(e); }
        }
        if (html == null){ el.previewErr.textContent = 'Preview hiba: ' + (lastErr || 'ismeretlen hiba'); return; }
        const ifr = el.preview; const doc = ifr.contentDocument;
        doc.open(); doc.write(html); doc.close();
        await ensureLibs(doc); runScripts(doc);
    }
    function runScripts(doc){
        Array.prototype.slice.call(doc.querySelectorAll('script')).forEach(function(s){
            const n = doc.createElement('script');
            if (s.getAttribute('src')) n.setAttribute('src', s.getAttribute('src')); else n.text = s.text || s.textContent || '';
            Array.prototype.slice.call(s.attributes).forEach(function(a){ if (a.name !== 'src') n.setAttribute(a.name, a.value); });
            s.parentNode.insertBefore(n, s); s.parentNode.removeChild(s);
        });
    }
    function ensureScript(doc, src){
        return new Promise(function(resolve){
            if ([].some.call(doc.scripts, function(s){ return s.src && s.src.indexOf(src) !== -1; })) return resolve();
            const e = doc.createElement('script'); e.async = false; e.src = src; e.onload = function(){ resolve(); };
            doc.head.appendChild(e);
        });
    }
    async function ensureLibs(doc){
        await ensureScript(doc, 'https://cdn.jsdelivr.net/npm/chart.js');
        await ensureScript(doc, 'https://code.jquery.com/jquery-3.7.1.min.js');
    }

    // —— Metric list / load / save ——
    async function refreshMetricList(){
        const sel = el.metricSelect; sel.innerHTML = '<option value="">– betöltés… –</option>';
        try {
            const resp = await fetch(listUrl, { credentials: 'same-origin' });
            if (!resp.ok) throw new Error('HTTP ' + resp.status);
            const arr = await resp.json();
            sel.innerHTML = '<option value="">– válassz –</option>';
            (arr || []).forEach(function(name){ const o = document.createElement('option'); o.value = o.text = name; sel.appendChild(o); });
        } catch(err){
            sel.innerHTML = '<option value="">(nincs lista endpoint)</option>';
        }
    }
    async function loadMetric(name){
        const n = (name || el.metricName.value || el.metricSelect.value || '').trim();
        if (!n){ alert('Adj meg egy fájlnevet vagy válassz a listából.'); return; }
        // POST + antiforgery; több kulcsnév próba (controller szignatúra-független)
        const keyCandidates = ['name','metricName','file','fileName'];
        let txt = null, lastErr = null;
        for (const key of keyCandidates){
            try {
                const resp = await postForm(loadUrl, { [key]: n });
                if (resp.ok){ txt = await resp.text(); break; }
                lastErr = 'HTTP ' + resp.status;
            } catch(e){ lastErr = e && e.message ? e.message : String(e); }
        }
        if (txt == null){ alert('Betöltési hiba: ' + (lastErr || 'ismeretlen')); return; }
        el.metricName.value = n; el.rawInput.value = txt;
        const b = (findBlocks(txt).find(function(x){ return isChartLike(x.text); }) || {}).text;
        if (b){
            const st = parseChartBlock(b);
            el.querySql.value = st.query || '';
            el.series.value = st.series || '';
            el.legends.value = st.legends || '';
            el.groupby.value = st.groupby || '';
            const m = /title\s*:\s*\"([\s\S]*?)\"/.exec(st.formatting || '');
            el.title.value = m ? m[1] : '';
            generateThtml();
        } else {
            initSmoke();
        }
    }
    async function saveMetric(asNew){
        let n = (el.metricName.value || '').trim();
        if (asNew){ const nn = prompt('Új fájlnév:', n || 'metric_new.thtml'); if (!nn) return; n = nn.trim(); el.metricName.value = n; }
        if (!n){ alert('Adj meg egy fájlnevet.'); return; }
        const body = el.generated.value || generateThtml();
        const resp = await postForm(saveUrl, { name: n, content: body });
        if (!resp.ok){ alert('Mentési hiba: HTTP ' + resp.status); return; }
        alert('Elmentve: ' + n);
        try { await refreshMetricList(); } catch(_){ }
    }

    // —— Smoke test ——
    function initSmoke(){
        const smoke = "SELECT 2023 AS OrderYear, 'FR' AS CountryRegionCode, 120000 AS TotalSales";
        el.querySql.value = smoke;
        el.series.value = 'TotalSales';
        el.legends.value = 'OrderYear';
        el.groupby.value = 'CountryRegionCode';
        el.title.value = 'Smoke test – static';
        el.generated.value = buildChartBlock({ query: smoke, representation: 'barchart', series: 'TotalSales', legends: 'OrderYear', groupby: 'CountryRegionCode', formatting: '{ title: "Smoke test – static" }' });
    }

    // —— Bindings ——
    $('#btnRefreshList').on('click', refreshMetricList);
    $('#metricSelect').on('change', function(){ if (this.value) { el.metricName.value = this.value; loadMetric(this.value); } });
    $('#btnLoad').on('click', function(){ loadMetric(); });
    $('#btnSave').on('click', function(){ saveMetric(false); });
    $('#btnSaveAs').on('click', function(){ saveMetric(true); });

    $('#btnBuild').on('click', function(){
        el.generated.value = buildChartBlock({
            query: el.querySql.value, representation: 'barchart', series: el.series.value,
            legends: el.legends.value, groupby: el.groupby.value,
            formatting: el.title.value ? '{ title: "' + el.title.value.replaceAll('"','\\\"') + '" }' : ''
        });
    });
    $('#btnGenerateThtml').on('click', generateThtml);
    $('#btnPreview').on('click', refreshPreview);

    // —— Init ——
    initSmoke();
    refreshMetricList();
})();
    </script>
}
